---
title: |
  <span style="display: inline-flex; align-items: center;">
    <img src="images/spotify.png" style="height: 40px; margin-right: 10px;">
    Tracks and Stats 🎵
  </span>
subtitle: "Where Music Meets Analytics"
author: "Dev Lala"
format:
  html:
    code-fold: true
    code-summary: "Show the code"
    theme:
      light: minty
      dark: darkly
    css: spotifystyle.css
    toc: false
    toc-location: left
    number-sections: false
    smooth-scroll: true
    title-block-banner: true
    page-layout: full
editor: visual
---

## Popular Artists 🎤

::: {style="display: flex; align-items: center; justify-content: flex-start; gap: 30px; margin-bottom: 40px;"}
<img src="images/kendrick.jpg" width="200px" style="border-radius: 50%;"/> <img src="images/eminem.jpg" width="200px" style="border-radius: 50%;"/> <img src="images/coldplay.jpg" width="200px" style="border-radius: 50%;"/> <img src="images/gorillaz.jpg" width="200px" style="border-radius: 50%;"/> <img src="images/empire.jpg" width="200px" style="border-radius: 50%;"/>
:::

While these are some of my personal favorite artists—the ones that define my everyday playlists and late-night loops—this project takes a broader lens. I’ll be exploring Spotify data to analyze trends across various artists, genres, and tracks to uncover the characteristics that make a song stand out and rise to popularity. It’s less about personal taste, and more about what the data reveals about music that resonates with millions

# Intro Track 🎙️

Welcome to Tracks and Stats — where the world of music meets the power of data!

In this project, we dive into Spotify’s data exports to uncover the trends and characteristics behind today’s most popular songs. Using real-world analytics, we work toward building The Ultimate Playlist — a collection inspired by the legendary spirit of Mr. Barney Stinson’s “All Rise” playlist, but customized to reflect our own vision of what ultimate music sounds like.

Through the lens of Tracks and Stats, we explore top artists, trending songs, and musical patterns that define what makes a track truly unforgettable.

# Main Chorus 🎶

-   Ingest and clean Spotify datasets to prepare for analysis.

-   Combine multiple data sources to create a richer dataset.

-   Perform descriptive analysis and visualize key trends.

-   Apply inferential modeling to build **The Ultimate Playlist**.

# **Data Soundcheck** 📀

In this section, I’ve loaded and cleaned two datasets: one with song characteristics like acousticness and tempo, and another with playlist details such as track order and metadata. These datasets are now ready for analysis.

### [Track Traits 🎸]{style="color:#1DB954;"}

This section displays a dataset of songs with key traits like acousticness, danceability, tempo, loudness, popularity, and more. Each row represents a song along with its ID, release date & year, artist and various other characteristics

```{r setup, include=FALSE}
library(dplyr)
library(tidyr)
library(stringr)
library(readr)
library(tidyverse)
library(DT)
```

```{r load-data, message=FALSE, warning=FALSE}

# Function to load and clean songs data
load_songs <- function() {
  dir_name <- file.path("data", "mp03")
  dir.create(dir_name, showWarnings = FALSE, recursive = TRUE)
  
  file_path <- file.path(dir_name, "spotify_songs.csv")
  
  if (!file.exists(file_path)) {
    download.file(
      url = "https://raw.githubusercontent.com/gabminamedez/spotify-data/refs/heads/master/data.csv",
      destfile = file_path,
      extra = "-L -A 'Mozilla/5.0'", # Trick GitHub download
      method = "libcurl"
    )
  }
  
  songs_data <- read.csv(file_path)
  
  clean_artist_string <- function(x) {
    str_replace_all(x, "\\['", "") |> 
      str_replace_all("'\\]", "") |> 
      str_replace_all(" '", "") 
  }
  
  songs_clean <- songs_data |> 
    separate_longer_delim(artists, ",") |> 
    mutate(artist = clean_artist_string(artists)) |> 
    select(-artists)
  
  return(songs_clean)
}

# Load and clean the data
songs <- load_songs()

```

```{r}
library(DT)

datatable(
  head(songs, 100),
  options = list(
    pageLength = 10,
    autoWidth = TRUE,
    dom = 'lfrtip' # keep 'Show entries' (l), 'Search' (f), table (t), pagination (p)
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(songs),
    backgroundColor = '#121212',  # Black background
    color = '#00FF00'  # Bright green text
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      // Change text color of 'Show entries' label
      $(el).parent().find('label').css('color', '#00FF00');
      // Change text color inside 'Search' input
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      // Also adjust the dropdown box
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

### [Playlist Breakdown 🎧]{style="color:#1DB954;"}

This section showcases a dataset of playlists, detailing the songs included, their order, and additional metadata like artist names and track attributes. It offers a comprehensive view of how different songs are grouped in playlists, a.k.a **‘Rectangle’ the Playlist Data.**

```{r label: load-playlists, message=FALSE, warning=FALSE}

library(jsonlite)
library(purrr)
library(dplyr)
library(tidyr)
library(stringr)

#Only reading 5 files to avoid performance issues 

load_playlists <- function(n_files = 5) {
  # Create directory
  dir_name <- file.path("data", "mp03_playlists")
  dir.create(dir_name, showWarnings = FALSE, recursive = TRUE)

  # Base URL and filenames
  base_url <- "https://raw.githubusercontent.com/DevinOgrady/spotify_million_playlist_dataset/refs/heads/main/data1/mpd.slice.0-999.json"
  slice_starts <- seq(0, 999000, by = 1000)
  filenames <- paste0("mpd.slice.", slice_starts, "-", slice_starts + 999, ".json")

  #Selected only the first few files to download and read
  selected_files <- filenames[1:n_files]

  #Safe JSON reader
  safe_read_json <- purrr::possibly(fromJSON, otherwise = NULL)

  playlists_list <- list()

  for (filename in selected_files) {
    url <- paste0(base_url, filename)
    local_file <- file.path(dir_name, filename)

    if (!file.exists(local_file)) {
      tryCatch({
        download.file(url, destfile = local_file, method = "libcurl", quiet = TRUE)
        message(paste("Downloaded:", filename))
      }, error = function(e) {
        message(paste("Failed to download:", filename))
      })
    }

    #Reading the file
    if (file.exists(local_file)) {
      playlists_list[[filename]] <- safe_read_json(local_file, flatten = TRUE)
    }
  }

  return(playlists_list)
}

#Loading just 5 files 
playlists_raw <- load_playlists(n_files = 5)

```

```{r}
#Saving the raw playlists
saveRDS(playlists_raw, "data/playlists_raw.rds")
```

```{r}
library(purrr)
library(dplyr)
library(tidyr)
library(stringr)

# Strip prefix like "spotify:track:" etc.
strip_spotify_prefix <- function(x) {
  str_extract(x, ".*:.*:(.*)")
}

#Combining all playlists from loaded list
all_playlists <- map_dfr(playlists_raw, function(file) {
  file$playlists
})


#Trying the "rectangle" nested list to a tidy table
rectified_data <- all_playlists %>%
  select(
    playlist_name = name,
    playlist_id = pid,
    playlist_followers = num_followers,
    tracks
  ) %>%
  unnest(tracks) %>%
  group_by(playlist_id) %>%
  mutate(
    playlist_position = row_number(),
    artist_name = map_chr(artist_name, 1, .default = NA_character_),
    artist_id = strip_spotify_prefix(artist_uri),
    track_name = track_name,
    track_id = strip_spotify_prefix(track_uri),
    album_name = album_name,
    album_id = strip_spotify_prefix(album_uri),
    duration = duration_ms
  ) %>%
  ungroup() %>%
  select(
    playlist_name, playlist_id, playlist_position, playlist_followers,
    artist_name, artist_id, track_name, track_id,
    album_name, album_id, duration
  )

rectified_data <- all_playlists %>%
  select(
    playlist_name = name,
    playlist_id = pid,
    playlist_followers = num_followers,
    tracks
  ) %>%
  unnest(tracks) %>%
  group_by(playlist_id) %>%
  mutate(
    playlist_position = row_number(),
    artist_name = map_chr(artist_name, 1, .default = NA_character_),
    artist_id = strip_spotify_prefix(artist_uri),
    track_name = track_name,
    track_id = strip_spotify_prefix(track_uri),
    album_name = album_name,
    album_id = strip_spotify_prefix(album_uri),
    duration = duration_ms
  ) %>%
  ungroup() %>%
  select(
    playlist_name, playlist_id, playlist_position, playlist_followers,
    artist_name, artist_id, track_name, track_id,
    album_name, album_id, duration
  )

#Previewing first few rows
head(rectified_data, 10)

```

```{r}
library(DT)

#Displaying Styled table showing 4 key columns from your rectified Task 3 data
datatable(
  rectified_data %>%
    select(playlist_id, playlist_name, track_name, artist_name),
  options = list(
    pageLength = 10,
    autoWidth = TRUE,
    dom = 'lfrtip'  # show entries dropdown, search bar, pagination
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = c("playlist_id", "playlist_name", "track_name", "artist_name"),
    backgroundColor = '#121212',  # black background
    color = '#00FF00'             # neon green text
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")

```

# Exploring the Tracks 🔍 🎵

1.  How many distinct tracks and artists are represented in the playlist data?

```{r}
library(dplyr)
library(tibble)
library(DT)

#Calculating distinct counts
num_unique_tracks <- rectified_data %>%
  distinct(track_id) %>%
  nrow()

num_unique_artists <- rectified_data %>%
  distinct(artist_id) %>%
  nrow()

#Displaying themed results table
distinct_summary <- tibble::tibble(
  Metric = c("Number of unique tracks", "Number of unique artists"),
  Count = c(num_unique_tracks, num_unique_artists)
)

#Displaying with dark theme
datatable(
  distinct_summary,
  options = list(
    pageLength = 5,
    autoWidth = TRUE,
    dom = 't'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(distinct_summary),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")


```

2.  What are the 5 most popular tracks in the playlist data?

```{r}
# Figuring out the 5 most popular tracks by how often they show up in playlists
top5_tracks <- rectified_data %>%
  group_by(track_name, artist_name) %>%
  summarise(appearances = n(), .groups = "drop") %>%
  arrange(desc(appearances)) %>%
  slice_head(n = 5)

# Displaying the top 5 in my usual dark theme
datatable(
  top5_tracks,
  options = list(
    pageLength = 5,
    autoWidth = TRUE,
    dom = 't'  # table only, no search/pagination
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(top5_tracks),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")

```

3.  What is the most popular track in the playlist data that *does not have a corresponding entry in the song characteristics* data?

```{r}
#Finding the most popular track from playlists that’s missing in the songs dataset

#Step 1: Finding track_ids that are in rectified_data but NOT in songs
unmatched_tracks <- rectified_data %>%
  filter(!(track_id %in% songs$track_id))

#Step 2: Counting how often each unmatched track appears
most_popular_unmatched <- unmatched_tracks %>%
  group_by(track_name, artist_name, track_id) %>%
  summarise(appearances = n(), .groups = "drop") %>%
  arrange(desc(appearances)) %>%
  slice_head(n = 1)

#Step 3: Displaying it in my usual black + neon theme
datatable(
  most_popular_unmatched,
  options = list(
    pageLength = 1,
    autoWidth = TRUE,
    dom = 't'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(most_popular_unmatched),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")

```

4.  According to the song characteristics data, what is the most “danceable” track? How often does it appear in a playlist?

```{r}
# Finding the most danceable song (with a valid ID)
most_danceable_song <- songs %>%
  filter(!is.na(id)) %>%
  arrange(desc(danceability)) %>%
  slice_head(n = 1)

# Extracting the actual track ID to match with playlist data
most_danceable_id <- most_danceable_song$id[[1]]

# Counting how many times this song appears in playlists
danceable_count <- rectified_data %>%
  filter(track_id == most_danceable_id) %>%
  nrow()

# Putting it all into a styled summary table
danceable_summary <- tibble::tibble(
  Track_Name = most_danceable_song$name,
  Artist = most_danceable_song$artist,
  Danceability = most_danceable_song$danceability,
  Playlist_Appearances = danceable_count
)

# Showing it in my signature neon green & black theme 💚🖤
datatable(
  danceable_summary,
  options = list(
    pageLength = 1,
    autoWidth = TRUE,
    dom = 't'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(danceable_summary),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")


```

-\> According to the song characteristics data, the most danceable track is "Funky Cold Medina". However, it does not appear in any of the playlists from the playlist dataset.

5.  Which playlist has the longest average track length?

```{r}
# Finding the playlist with the longest average track length (in milliseconds)
longest_avg_playlist <- rectified_data %>%
  group_by(playlist_name) %>%
  summarise(avg_duration_ms = mean(duration, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(avg_duration_ms)) %>%
  slice_head(n = 1)

# Converting duration from ms to mm:ss format
longest_avg_playlist <- longest_avg_playlist %>%
  mutate(
    avg_duration_min = floor(avg_duration_ms / 60000),
    avg_duration_sec = floor((avg_duration_ms %% 60000) / 1000),
    Avg_Track_Length = paste0(avg_duration_min, "m ", avg_duration_sec, "s")
  ) %>%
  select(Playlist = playlist_name, Avg_Track_Length)

# Displaying the playlist name + average duration in my neon theme 🖤💚
datatable(
  longest_avg_playlist,
  options = list(
    pageLength = 1,
    autoWidth = TRUE,
    dom = 't'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(longest_avg_playlist),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")

```

6.  What is the most popular playlist on Spotify?

```{r}
#Getting the playlist with the most followers — basically Spotify royalty
most_popular_playlist <- rectified_data %>%
  select(playlist_name, playlist_followers) %>%
  distinct() %>%
  arrange(desc(playlist_followers)) %>%
  slice_head(n = 1)

#Displaying it in my dark green neon setup
datatable(
  most_popular_playlist,
  options = list(
    pageLength = 1,
    autoWidth = TRUE,
    dom = 't'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(most_popular_playlist),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")


```

# Melodic Metrics 📈 🎼

This task visually explores the data to uncover what sets the most popular songs on Spotify apart.

```{r}
library(stringr)

#Clean the track_id so it matches the fmat in songs_id
rectified_data <- rectified_data %>%
  mutate(track_id = str_extract(track_id, "[^:]+$"))
```

```{r, message=FALSE, warning=FALSE}
library(dplyr)

# Joining playlist and song characteristics data on track ID
songs_clean <- songs %>%
  distinct(id, .keep_all = TRUE)  # Fixed syntax for distinct()

combined_data <- rectified_data %>%
  inner_join(songs_clean, by = c("track_id" = "id"))  # Ensure columns match

# Force some visible output for rendering
head(combined_data)  # Fixed spacing in function call
```

### Is the popularity column correlated with the number of playlist appearances? If so, to what degree?

```{r}
library(ggplot2)
library(dplyr)

# Create data frame with track popularity and playlist appearance counts
popularity_vs_appearances <- combined_data %>%
  group_by(track_id, popularity) %>%
  summarise(playlist_appearances = n(), .groups = "drop")

# Step 1: Bin playlist appearance counts
binned_data <- popularity_vs_appearances %>%
  mutate(bin = cut(playlist_appearances, 
                   breaks = c(0, 5, 10, 20, 50, 100, Inf),
                   labels = c("0–5", "6–10", "11–20", "21–50", "51–100", "100+")))

# Step 2: Plot as boxplot with your aesthetic
ggplot(binned_data, aes(x = bin, y = popularity)) +
  geom_boxplot(fill = "#00FF00", alpha = 0.7, color = "#00FF00") +
  labs(
    title = "Spotify Popularity by Playlist Appearance Group",
    x = "Playlist Appearance Bin",
    y = "Popularity Score"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    text = element_text(color = "#00FF00"),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00")
  )


```

**Analysis** - This boxplot shows that tracks appearing in more playlists generally have higher Spotify popularity scores. Median popularity rises with playlist appearances, especially beyond 20. Still, the wide range within each group suggests that **playlist exposure helps, but is not the only factor** driving popularity.

### In what year were the most popular songs released?

```{r}
library(ggplot2)
library(dplyr)

# Filter popular songs (popularity ≥ 75)
popular_songs <- combined_data %>%
  filter(popularity >= 75, !is.na(year))

# Count how many were released per year
yearly_counts <- popular_songs %>%
  count(year) %>%
  filter(year >= 1995)  # optional: filter to keep it clean

# Plot - clean, rotated, and readable
ggplot(yearly_counts, aes(x = factor(year), y = n)) +
  geom_col(fill = "#00FF00", alpha = 0.8) +
  labs(
    title = "When Were the Most Popular Songs Released?",
    x = "Release Year",
    y = "Number of Popular Songs"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    axis.text = element_text(color = "#00FF00", angle = 45, hjust = 1),
    axis.title = element_text(color = "#00FF00"),
    text = element_text(color = "#00FF00")
  )

```

**Analysis** - Most popular songs were released after 2015, with a sharp rise in recent years. This aligns with how newer music dominates playlists due to recency bias and platform algorithms.

### In what year did danceability peak?

```{r setup-packages, include=FALSE}
#Loading Animation libraries
library(gganimate)
library(gifski)
```

```{r}
library(ggplot2)
library(dplyr)
library(gganimate)

# Step 1: Filter for popular songs
popular_dance <- combined_data %>%
  filter(popularity >= 75, !is.na(danceability), !is.na(year))

# Step 2: Calculate average danceability by year
dance_by_year <- popular_dance %>%
  group_by(year) %>%
  summarize(avg_danceability = mean(danceability)) %>%
  filter(year >= 1995)

# Step 3: Create animated line chart
p <- ggplot(dance_by_year, aes(x = year, y = avg_danceability)) +
  geom_line(color = "#00FF00", size = 1.5) +
  geom_point(color = "#00FF00", size = 3) +
  labs(
    title = "Danceability Trends Over Time",
    subtitle = "Year: {frame_time}",
    x = "Year",
    y = "Average Danceability"
  ) +
  theme_minimal(base_size = 15) +
  theme(
    plot.background = element_rect(fill = "#121212"),
    panel.background = element_rect(fill = "#121212"),
    text = element_text(color = "#00FF00"),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(size = 18, face = "bold")
  ) +
  transition_reveal(year)

# Step 4: Render animation (and hide output in final render)
invisible(
  animate(p, width = 800, height = 500, fps = 10, duration = 8, renderer = gifski_renderer())
)

```

**Analysis -** Danceability of popular songs steadily increased over time, peaking around **2019–2020**. This reflects the shift toward more rhythm-driven, upbeat music — possibly influenced by streaming-era pop, TikTok trends, and global dance tracks dominating the charts.

### Which decade is most represented on user playlists? 

```{r}
library(dplyr)
library(ggplot2)

# Step 1: Create decade column
decade_counts <- combined_data %>%
  filter(!is.na(year)) %>%
  mutate(decade = (year %/% 10) * 10) %>%
  count(decade)

# Step 2: Plot the decade frequency
ggplot(decade_counts, aes(x = factor(decade), y = n)) +
  geom_col(fill = "#00FF00", alpha = 0.8) +
  labs(
    title = "Most Represented Decades on Spotify Playlists",
    x = "Decade",
    y = "Number of Tracks"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212"),
    panel.background = element_rect(fill = "#121212"),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    text = element_text(color = "#00FF00"),
    plot.title = element_text(face = "bold")
  )

```

**Analysis** - The **2010s** dominate user playlists, followed by the 2000s. This reflects user preferences skewing toward more recent decades, likely due to recency, nostalgia, and streaming platform curation that favors modern music.

### Polar (circular) coordinates

```{r}
library(ggplot2)
library(dplyr)

# Updated readable labels (slash format, no flats)
key_labels <- c("C", "C#/Db", "D", "D#/Eb", "E", "F", 
                "F#/Gb", "G", "G#/Ab", "A", "A#/Bb", "B")

# Count key frequencies
key_counts <- combined_data %>%
  count(key) %>%
  mutate(
    key_label = factor(key_labels[key + 1], levels = key_labels)
  )

# Polar plot
ggplot(key_counts, aes(x = key_label, y = n, fill = key_label)) +
  geom_bar(stat = "identity", color = "white", width = 1) +
  coord_polar(start = 0) +
  scale_fill_manual(values = rep("#00FF00", 12)) +
  labs(
    title = "Distribution of Musical Keys",
    x = NULL,
    y = "Number of Songs"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white", linewidth = 0.3),
    panel.grid.minor = element_blank(),
    axis.text.y = element_text(color = "#00FF00"),
    axis.text.x = element_text(color = "#00FF00", size = 12, vjust = -0.8),  # pull labels above border
    axis.title.y = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold"),
    legend.position = "none"
  )

```

**Analysis** - The distribution of track lengths shows a clear peak between **3 to 4 minutes** (around **180–240 seconds**), with the most popular duration near **210 seconds**. This suggests that mid-length songs are the most playlist-friendly—long enough to feel complete but short enough to hold attention. Tracks that are very short or very long appear far less frequently, likely because they’re either intros/skits or extended versions not suited for general playlists.

### What are the most popular track lengths? (Are short tracks, long tracks, or something in between most commonly included in user playlists

```{r}
library(ggplot2)
library(dplyr)

# Convert milliseconds to seconds (if needed)
lengths_data <- combined_data %>%
  mutate(duration_sec = duration / 1000) %>%
  filter(duration_sec >= 60, duration_sec <= 600)  # Keep songs between 1–10 min

# Histogram of track lengths
ggplot(lengths_data, aes(x = duration_sec)) +
  geom_histogram(fill = "#00FF00", color = "white", binwidth = 10) +
  labs(
    title = "Distribution of Track Lengths in Playlists",
    x = "Track Length (seconds)",
    y = "Number of Tracks"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white", linewidth = 0.3),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold")
  )

```

**Analysis** - Most tracks in user playlists fall between **3 to 4 minutes**, with a noticeable peak around **210 seconds**. This suggests that songs of moderate length are the most commonly included—probably because they strike the right balance between listener attention and playlist flow. Very short or long tracks are much less frequent, indicating that mid-length songs tend to be the sweet spot for popularity.

## Two more visualization

```{r}
library(dplyr)

set.seed(42)

songs <- tibble(
  id = paste0("dummy_id_", 1:10000),
  name = paste0("Track_", 1:10000),
  duration_ms = sample(120000:300000, 10000, replace = TRUE),   # realistic 2-5 min durations
  release_date = sample(1928:2020, 10000, replace = TRUE),       # from 1928 to 2020
  year = release_date,                                          # duplicate column if needed
  acousticness = runif(10000, min = 0, max = 1),
  danceability = runif(10000, min = 0.2, max = 0.9),             # more danceable overall
  energy = runif(10000, min = 0.2, max = 1),
  instrumentalness = runif(10000, min = 0, max = 0.8),
  liveness = runif(10000, min = 0.1, max = 0.6),
  loudness = rnorm(10000, mean = -10, sd = 5),
  speechiness = runif(10000, min = 0.02, max = 0.3),
  tempo = runif(10000, min = 60, max = 180),                     # 60–180 bpm
  valence = runif(10000, min = 0.1, max = 0.9),
  mode = sample(0:1, 10000, replace = TRUE),
  key = sample(0:11, 10000, replace = TRUE),
  popularity = round(rbeta(10000, 2, 5) * 100),                  # many songs low popularity, few very high
  explicit = sample(0:1, 10000, replace = TRUE, prob = c(0.85, 0.15)),
  artist = paste0("Artist_", 1:10000)
)
```

```{r}
library(ggplot2)
library(dplyr)
library(lubridate)  # for extracting year from date

# Step 1: Filter popular songs
popular_songs <- combined_data %>%
  filter(popularity >= 60) %>%
  mutate(release_year = year(ymd(release_date)))  # convert to year

# Step 2: Plot release year distribution with custom dark theme
ggplot(popular_songs, aes(x = release_year)) +
  geom_histogram(binwidth = 1, fill = "#00FF00", color = "white", boundary = 1928) +
  labs(
    title = "Release Years of Most Popular Songs",
    x = "Release Year",
    y = "Number of Songs"
  ) +
  scale_x_continuous(breaks = seq(1928, 2020, by = 10), expand = c(0, 0)) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white", linewidth = 0.3),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

Q3 In what year did danceability peak?

```{r}
library(dplyr)
library(ggplot2)
library(lubridate)

# Step 1: Filter for popular songs
popular_songs <- combined_data %>%
  filter(popularity >= 60) %>%
  mutate(release_year = year(ymd(release_date)))

# Step 2: Calculate average danceability by release year
danceability_by_year <- popular_songs %>%
  group_by(release_year) %>%
  summarise(avg_danceability = mean(danceability, na.rm = TRUE)) %>%
  ungroup()

# Step 3: Plot the trend with custom dark theme
ggplot(danceability_by_year, aes(x = release_year, y = avg_danceability)) +
  geom_line(color = "#00FF00", size = 1.2) +
  geom_point(color = "white", size = 2) +
  labs(
    title = "Danceability Trend Over Release Years",
    x = "Release Year",
    y = "Average Danceability"
  ) +
  scale_x_continuous(breaks = seq(1928, 2023, by = 10), expand = c(0, 0)) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white", linewidth = 0.3),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

Q4 Which decade is most represented on user playlists? (The integer division (`%/%`) operator may be useful for computing decades from years.)

```{r}
#| echo: true
#| eval: true
#| include: false
library(dplyr)
library(ggplot2)
library(lubridate)

# Safely parse release_date and create decade
combined_data <- combined_data %>%
  mutate(
    parsed_date = suppressWarnings(ymd(release_date)),
    release_year = year(parsed_date),
    decade = (release_year %/% 10) * 10
  ) %>%
  filter(!is.na(decade))  # Keep only valid years
```

```{r}
library(ggplot2)
library(dplyr)
library(lubridate)

# Step 1: Create decade column from release_date
combined_data <- combined_data %>%
  mutate(decade = (year(ymd(release_date)) %/% 10) * 10)

# Step 2: Plot with dark theme
ggplot(combined_data, aes(x = decade)) +
  geom_histogram(binwidth = 10, fill = "#00FF00", color = "white", boundary = 0) +
  scale_x_continuous(breaks = seq(1920, 2030, by = 10)) +
  labs(
    title = "Histogram of Songs by Release Decade",
    x = "Decade",
    y = "Number of Songs"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white", linewidth = 0.3),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold")
  )
```

Q5 Create a plot of key frequency among songs. Because musical keys exist in a ‘cycle’, your plot should use polar (circular) coordinates.

```{r}
library(ggplot2)
library(dplyr)

# Step 1: Replace key numbers with note labels
key_labels <- c("C", "C#", "D", "D#", "E", "F", 
                "F#", "G", "G#", "A", "A#", "B")

key_counts <- combined_data %>%
  filter(!is.na(key)) %>%
  count(key) %>%
  mutate(key_label = factor(key_labels[key + 1], levels = key_labels))  # +1 because R is 1-indexed

# Step 2: Polar bar chart with your custom theme
ggplot(key_counts, aes(x = key_label, y = n)) +
  geom_col(fill = "#00FF00", color = "white", width = 1) +
  coord_polar(start = 0) +
  labs(
    title = "Distribution of Songs by Musical Key",
    x = "",
    y = "Number of Songs"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid = element_line(color = "white", linewidth = 0.3),
    axis.text = element_text(color = "#00FF00", size = 12),
    axis.title.y = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold"),
    axis.text.x = element_text(vjust = -0.5)  # Move labels slightly outward
  )
```

Q6 What are the most popular track lengths? (Are short tracks, long tracks, or something in between most commonly included in user playlists?)

```{r}
library(ggplot2)
library(dplyr)

# Step 1: Use combined_data and convert duration to minutes
length_data <- combined_data %>%
  mutate(duration_minutes = duration / 60000) %>%
  filter(duration_minutes >= 1, duration_minutes <= 10)  # Limit to 1–10 minutes

# Step 2: Plot histogram of track lengths
ggplot(length_data, aes(x = duration_minutes)) +
  geom_histogram(binwidth = 0.5, fill = "#00FF00", color = "white", boundary = 0) +
  labs(
    title = "Distribution of Track Lengths in Playlists",
    x = "Duration (minutes)",
    y = "Number of Songs"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white", linewidth = 0.3),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold")
  )
```

**Analysis** - Based on the distribution, most songs in user playlists have a duration between 2 to 4 minutes, suggesting that medium-length tracks are the most commonly included.

Q7 Pose and visually answer at least two more other exploratory questions.

### Additional Exploratory questions

#### 1️⃣ Are explicit songs more or less popular than non-explicit songs?

```{r}
library(ggplot2)
library(dplyr)

# Step 1: Create popularity buckets using combined_data
playlist_songs <- combined_data %>%
  mutate(
    popularity_bucket = case_when(
      popularity < 20 ~ "0–19",
      popularity >= 20 & popularity < 40 ~ "20–39",
      popularity >= 40 & popularity < 60 ~ "40–59",
      popularity >= 60 & popularity < 80 ~ "60–79",
      popularity >= 80 ~ "80–100"
    )
  )

# Step 2: Stacked bar chart of explicit vs non-explicit songs
ggplot(playlist_songs, aes(x = popularity_bucket, fill = factor(explicit))) +
  geom_bar(position = "fill") +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_manual(
    values = c("0" = "#56B4E9", "1" = "#E69F00"),  # Non-explicit = blue, Explicit = orange
    labels = c("Non-Explicit", "Explicit")
  ) +
  labs(
    title = "Proportion of Explicit vs Non-Explicit Songs by Popularity Range",
    x = "Popularity Range",
    y = "Proportion of Songs",
    fill = "Explicit Content"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white", linewidth = 0.3),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold")
  )
```

**Analysis** - The plot shows that explicit and non-explicit songs are fairly evenly distributed across all popularity ranges. Explicit songs consistently make up about half of the songs, regardless of popularity level. There isn’t a strong trend suggesting that explicit songs are significantly more or less popular compared to non-explicit songs.

#### 2️⃣ How does valence differ between popular and less popular songs?

```{r}
library(ggplot2)
library(dplyr)

# Use combined_data and classify songs by popularity
playlist_songs <- combined_data %>%
  mutate(popularity_group = ifelse(popularity >= 50, "Popular", "Less Popular"))

# Boxplot with customized colors and dark theme
ggplot(playlist_songs, aes(x = popularity_group, y = valence, fill = popularity_group)) +
  geom_boxplot(color = "white", width = 0.5, outlier.shape = NA) +  # White outlines
  scale_fill_manual(values = c("Popular" = "skyblue", "Less Popular" = "tomato")) +
  labs(
    title = "Valence Scores: Popular vs Less Popular Songs",
    x = "Popularity Group",
    y = "Valence (Positivity Score)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white", linewidth = 0.3),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold"),
    legend.position = "none"
  )
```

**Analysis** - The box plot shows that popular and less popular songs have a very similar distribution of valence scores. Both groups share nearly identical medians, though popular songs have a slightly tighter spread, suggesting a more consistent emotional tone. Overall, positivity does not strongly differ between the two groups.

## From Anchor to Anthem: Crafting the Playlist 💿 ➡️ 🎧

```{r}
#| echo: true
#| eval: true
#| include: false

library(tidyverse)

# Load the dataset
songs <- read_csv("https://raw.githubusercontent.com/gabminamedez/spotify-data/refs/heads/master/data.csv")

# Define your anchor songs by their names
anchor_songs <- songs %>%
  filter(name %in% c("Marsh", "Time to Pretend"))

# Heuristic thresholds
pop_threshold <- 50
year_buffer <- 2
tempo_buffer <- 10
acousticness_buffer <- 0.1

# Apply heuristics
related_songs <- songs %>%
  filter(
    !name %in% anchor_songs$name,  # Exclude anchors
    (
      # 1. Same key and similar tempo
      (key %in% anchor_songs$key & abs(tempo - anchor_songs$tempo[1]) <= tempo_buffer) |
      (key %in% anchor_songs$key & abs(tempo - anchor_songs$tempo[2]) <= tempo_buffer) |

      # 2. Same artist
      (artists %in% anchor_songs$artists) |

      # 3. Same year (+/- buffer)
      (year %in% (anchor_songs$year[1] - year_buffer):(anchor_songs$year[1] + year_buffer)) |
      (year %in% (anchor_songs$year[2] - year_buffer):(anchor_songs$year[2] + year_buffer)) |

      # 4. Similar acousticness
      (abs(acousticness - anchor_songs$acousticness[1]) <= acousticness_buffer |
       abs(acousticness - anchor_songs$acousticness[2]) <= acousticness_buffer)
    )
  )

# Filter to find songs that are NOT popular (popularity below threshold)
unpopular_candidates <- related_songs %>%
  filter(popularity < pop_threshold)

# Take top 20 candidates, at least 8 unpopular
top_candidates <- bind_rows(
  unpopular_candidates %>% slice_head(n = 8),
  related_songs %>% filter(!(id %in% unpopular_candidates$id)) %>% slice_head(n = 12)
)

# View results
top_candidates %>%
  select(name, artists, popularity, year, tempo, key, acousticness)

#Displaying the table
library(DT)

# Store only selected columns to avoid formatStyle mismatch
top_candidates_display <- top_candidates %>%
  select(name, artists, popularity, year, tempo, key, acousticness)
```

```{r}
# Display table without search bar and dropdown
datatable(
  top_candidates_display,
  options = list(
    dom = 't',         # table only (no search/dropdown)
    pageLength = 20,   # show all 20 rows
    autoWidth = TRUE
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(top_candidates_display),
    backgroundColor = '#121212',
    color = '#00FF00'
  )
```

Analysis - I used two anchor songs and applied a few heuristics to identify related songs for playlist building. Songs were filtered based on: - Similar key and tempo - Same artist or release year - Acoustic character or energy levels - Lower popularity (to discover hidden gems).

Out of the 20 songs shown below, at least 8 are not considered popular.

# From Vinyl to Viral 📼

# Bonus Track 🎞️

Catch a glimpse of the tracks in motion with these featured song videos.
