---
title: |
  <span style="display: inline-flex; align-items: center;">
    <img src="images/spotify.png" style="height: 40px; margin-right: 10px;">
    Tracks and Stats 🎵
  </span>
subtitle: "Where Music Meets Analytics"
author: "Dev Lala"
format:
  html:
    embed-resources: true
    code-fold: true
    code-summary: "Show the code"
    theme:
      light: minty
      dark: darkly
    css: spotifystyle.css
    toc: false
    toc-location: left
    number-sections: false
    smooth-scroll: true
    title-block-banner: true
    page-layout: full
editor: visual
---

## Popular Artists 🎤

::: {style="display: flex; align-items: center; justify-content: flex-start; gap: 30px; margin-bottom: 40px;"}
<img src="images/kendrick.jpg" width="200px" style="border-radius: 50%;"/> <img src="images/eminem.jpg" width="200px" style="border-radius: 50%;"/> <img src="images/coldplay.jpg" width="200px" style="border-radius: 50%;"/> <img src="images/gorillaz.jpg" width="200px" style="border-radius: 50%;"/> <img src="images/empire.jpg" width="200px" style="border-radius: 50%;"/>
:::

While these are some of my personal favorite artists—the ones that define my everyday playlists and late-night loops—this project takes a broader lens. I’ll be exploring Spotify data to analyze trends across various artists, genres, and tracks to uncover the characteristics that make a song stand out and rise to popularity. It’s less about personal taste, and more about what the data reveals about music that resonates with millions

# Intro Track 🎙️

Welcome to Tracks and Stats — where the world of music meets the power of data!

In this project, we dive into Spotify’s data exports to uncover the trends and characteristics behind today’s most popular songs. Using real-world analytics, we work toward building The Ultimate Playlist — a collection inspired by the legendary spirit of Mr. Barney Stinson’s “All Rise” playlist, but customized to reflect our own vision of what ultimate music sounds like.

Through the lens of Tracks and Stats, we explore top artists, trending songs, and musical patterns that define what makes a track truly unforgettable.

# Main Chorus 🎶

-   **Drop the Beat (Data Ingest & Cleaning):** Start by loading and cleaning up Spotify’s raw files — just like a DJ fine-tunes their setlist, we’re only keeping the clean stuff that’s ready to play.

<!-- -->

-   **Mashup Mode (Data Combination):** Merge different datasets to create a complete picture. One source gives us a glimpse, but combining them? That’s where the real story comes out.

-   **Now Playing: Trends (Descriptive Analysis):** Time to break down what the data’s actually saying — who’s trending, what’s gaining traction, and what stands out.

-   **Visual Bops (Data Visualization):** Turn those stats into visuals that speak louder than numbers ever could. The goal? Charts that actually *hit*.

-   **Remix the Hits (Inferential Modeling):** Use models to dig deeper and figure out what really makes a song pop — and from there, build *The Ultimate Playlist*.

# **Data Soundcheck** 📀

In this section, I’ve loaded and cleaned two datasets: one with song characteristics like acousticness and tempo, and another with playlist details such as track order and metadata. These datasets are now ready for analysis.

### [Track Traits 🎸]{style="color:#1DB954;"}

This section displays a dataset of songs with key traits like acousticness, danceability, tempo, loudness, popularity, and more. Each row represents a song along with its ID, release date & year, artist and various other characteristics

```{r, include=FALSE}
library(dplyr)
library(tidyr)
library(stringr)
library(readr)
library(tidyverse)
library(DT)
```

```{r, message=FALSE, warning=FALSE}

#Load and clean songs data
load_songs <- function() {
  dir_name <- file.path("data", "mp03")
  dir.create(dir_name, showWarnings = FALSE, recursive = TRUE)
  
  file_path <- file.path(dir_name, "spotify_songs.csv")
  
  if (!file.exists(file_path)) {
    download.file(
      url = "https://raw.githubusercontent.com/gabminamedez/spotify-data/refs/heads/master/data.csv",
      destfile = file_path,
      extra = "-L -A 'Mozilla/5.0'", # Trick GitHub download
      method = "libcurl"
    )
  }
  
  songs_data <- read.csv(file_path)
  
  clean_artist_string <- function(x) {
    str_replace_all(x, "\\['", "") |> 
      str_replace_all("'\\]", "") |> 
      str_replace_all(" '", "") 
  }
  
  songs_clean <- songs_data |> 
    separate_longer_delim(artists, ",") |> 
    mutate(artist = clean_artist_string(artists)) |> 
    select(-artists)
  
  return(songs_clean)
}

songs <- load_songs()

```

```{r}
library(DT)

datatable(
  head(songs, 100),
  options = list(
    pageLength = 10,
    autoWidth = TRUE,
    dom = 'lfrtip' 
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(songs),
    backgroundColor = '#121212',  # Black background
    color = '#00FF00'  # Bright green text
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      // Change text color of 'Show entries' label
      $(el).parent().find('label').css('color', '#00FF00');
      // Change text color inside 'Search' input
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      // Also adjust the dropdown box
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

### [Playlist Breakdown 🎧]{style="color:#1DB954;"}

This section showcases a dataset of playlists, detailing the songs included, their order, and additional metadata like artist names and track attributes. It offers a comprehensive view of how different songs are grouped in playlists, a.k.a **‘Rectangle’ the Playlist Data.**

```{r, message=FALSE, warning=FALSE, include=FALSE}
library(jsonlite)
library(purrr)
library(dplyr)
library(tidyr)
library(stringr)

load_playlists <- function(n_files = 5) {
  # 1. Create directory
  dir_name <- file.path("data", "mp03_playlists")
  dir.create(dir_name, showWarnings = FALSE, recursive = TRUE)

  # 2. Base URL
  base_url <- "https://raw.githubusercontent.com/DevinOgrady/spotify_million_playlist_dataset/refs/heads/main/data1/mpd.slice.0-999.json"
  slice_starts <- seq(0, 999000, by = 1000)  # all files
  filenames <- paste0("mpd.slice.", slice_starts, "-", slice_starts + 999, ".json")

  # 3. Download all files (responsibly)
  for (filename in filenames) {
    local_file <- file.path(dir_name, filename)
    if (!file.exists(local_file)) {
      tryCatch({
        download.file(
          url = paste0(base_url, filename),
          destfile = local_file,
          method = "libcurl",
          quiet = TRUE
        )
        message(paste("Downloaded:", filename))
      }, error = function(e) {
        message(paste("Failed to download:", filename))
      })
    }
  }

  # 4. Read only the first n_files into R
  safe_read_json <- purrr::possibly(fromJSON, otherwise = NULL)
  selected_files <- filenames[1:n_files]
  playlists_list <- list()

  for (filename in selected_files) {
    local_file <- file.path(dir_name, filename)
    if (file.exists(local_file)) {
      playlists_list[[filename]] <- safe_read_json(local_file, flatten = TRUE)
    }
  }

  return(playlists_list)
}

# Load only the first 5 files 
playlists_raw <- load_playlists(n_files = 5)
```

```{r}
# Save the raw playlists
saveRDS(playlists_raw, "data/playlists_raw.rds")
```

```{r, message=FALSE, warning=FALSE, include=FALSE}
# Load necessary libraries
library(purrr)
library(dplyr)
library(tidyr)
library(stringr)

# Load raw playlist data
playlists_raw <- readRDS("data/playlists_raw.rds")  

# Function to strip Spotify URI prefixes
strip_spotify_prefix <- function(x) {
  str_extract(x, ".*:.*:(.*)")
}

# Combine all playlist data from loaded list
all_playlists <- map_dfr(playlists_raw, ~ .x$playlists, .id = "source_file")

# Create rectified_data from nested structure
rectified_data <- all_playlists %>%
  select(
    playlist_name = name,
    playlist_id = pid,
    playlist_followers = num_followers,
    tracks
  ) %>%
  unnest(tracks) %>%
  mutate(
    playlist_position = row_number(),
    artist_name = map_chr(artist_name, 1, .default = NA_character_),
    artist_id = strip_spotify_prefix(artist_uri),
    track_name = track_name,
    track_id = str_extract(strip_spotify_prefix(track_uri), "[^:]+$"),
    album_name = album_name,
    album_id = strip_spotify_prefix(album_uri),
    duration = duration_ms
  ) %>%
  select(
    playlist_name, playlist_id, playlist_position, playlist_followers,
    artist_name, artist_id, track_name, track_id,
    album_name, album_id, duration
  )

# Clean song metadata
songs_clean <- songs %>%
  distinct(id, .keep_all = TRUE)

# Join playlist and song metadata
rectified <- rectified_data %>%
  inner_join(songs_clean, by = c("track_id" = "id"))

# Preview final joined dataset
head(rectified, 10)
```

```{r}
library(DT)

# Show the first 100 rows of rectified_data in a styled table
datatable(
  head(rectified, 100),
  options = list(
    pageLength = 10,
    autoWidth = TRUE,
    dom = 'lfrtip' 
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(rectified),
    backgroundColor = '#121212',  # black background
    color = '#00FF00'             # bright green text
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

# Exploring the Tracks 🔍 🎵

1.  How many distinct tracks and artists are represented in the playlist data?

```{r}
library(dplyr)
library(DT)

# 1A: How many distinct tracks?
distinct_tracks <- n_distinct(rectified$track_id)

# 1B: How many distinct artists?
distinct_artists <- n_distinct(rectified$artist_id)

# Create a small tibble to display both answers
q1_table <- tibble::tibble(
  Metric = c("Distinct Tracks", "Distinct Artists"),
  Count = c(distinct_tracks, distinct_artists)
)

# Now display the table nicely with your theme
datatable(
  q1_table,
  options = list(
    pageLength = 10,
    autoWidth = TRUE,
    dom = 'lfrtip'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(q1_table),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

2.  What are the 5 most popular tracks in the playlist data?

```{r}
library(dplyr)
library(DT)

# Q2: Get top 5 most popular tracks
top5_tracks <- rectified %>%
  count(track_name, sort = TRUE) %>%
  slice_head(n = 5)

# Display the result nicely with your dark theme
datatable(
  top5_tracks,
  options = list(
    pageLength = 5,
    autoWidth = TRUE,
    dom = 'lfrtip'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(top5_tracks),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

3.  What is the most popular track in the playlist data that *does not have a corresponding entry in the song characteristics* data?

```{r}
library(dplyr)
library(DT)

# Find the most popular tracks from rectified data
popular_tracks <- rectified %>%
  count(track_name, sort = TRUE)

# Find tracks in playlists but missing from songs dataset
tracks_not_in_songs <- anti_join(
  popular_tracks,
  songs,
  by = c("track_name" = "name")
)

# Get the most popular missing track
most_popular_missing_track <- tracks_not_in_songs %>%
  slice_head(n = 1)

# Display it nicely
datatable(
  most_popular_missing_track,
  options = list(
    pageLength = 1,
    autoWidth = TRUE,
    dom = 'lfrtip'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(most_popular_missing_track),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

4.  According to the song characteristics data, what is the most “danceable” track? How often does it appear in a playlist?

```{r}
library(dplyr)
library(DT)

# Find the most danceable track
most_danceable_track <- songs %>%
  arrange(desc(danceability)) %>%
  slice_head(n = 1)

# Display it 
datatable(
  most_danceable_track,
  options = list(
    pageLength = 1,
    autoWidth = TRUE,
    dom = 'lfrtip'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(most_danceable_track),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

```{r}
library(dplyr)
library(DT)

# Get the most danceable track name from songs
most_danceable_track_name <- songs %>%
  arrange(desc(danceability)) %>%
  slice_head(n = 1) %>%
  pull(name)

# Count how many times it appears in playlists (rectified data)
most_danceable_appearance_count <- rectified %>%
  filter(track_name == most_danceable_track_name) %>%
  nrow()

# Create a tibble to display the result
q4_appearance_table <- tibble::tibble(
  Most_Danceable_Track = most_danceable_track_name,
  Number_of_Appearances = most_danceable_appearance_count
)

# Display it 
datatable(
  q4_appearance_table,
  options = list(
    pageLength = 1,
    autoWidth = TRUE,
    dom = 'lfrtip'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(q4_appearance_table),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

According to the song characteristics data, the most danceable track is "Funky Cold Medina". However, it has only one appearance in the playlists from the playlist dataset.

5.  Which playlist has the longest average track length?

```{r}
library(dplyr)
library(DT)

# Find the playlist with the longest average track duration
longest_playlist <- rectified %>%
  group_by(playlist_id, playlist_name) %>%
  summarize(avg_duration = mean(duration, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(avg_duration)) %>%
  slice_head(n = 1)

# Display the result
datatable(
  longest_playlist,
  options = list(
    pageLength = 1,
    autoWidth = TRUE,
    dom = 'lfrtip'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(longest_playlist),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

6.  What is the most popular playlist on Spotify?

```{r}
library(dplyr)
library(DT)

# Join rectified_data with songs to get popularity info
most_popular_playlist <- rectified %>%
  select(playlist_name, playlist_followers) %>%
  distinct() %>%
  arrange(desc(playlist_followers)) %>%
  slice_head(n = 1)

# Display it 
datatable(
  most_popular_playlist,
  options = list(
    pageLength = 1,
    autoWidth = TRUE,
    dom = 't'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(most_popular_playlist),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

# Visualizing the Vibe 🎧📊

```{r, message=FALSE, warning=FALSE}
#| label: load-playlists
#| message: false
#| warning: false
#| include: false
library(dplyr)

# Joining playlist and song characteristics data on track ID
songs_clean <- songs %>%
  distinct(id, .keep_all = TRUE)

combined_data <- rectified %>%
  inner_join(songs_clean, by = c("track_id" = "id"))

# Force visible output for rendering
head(combined_data)
```

Q1 Is the popularity column correlated with the number of playlist appearances? If so, to what degree?

```{r, message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)

# Create data frame with track popularity and playlist appearance counts
popularity_vs_appearances <- rectified %>%
  group_by(track_id, popularity) %>%
  summarise(playlist_appearances = n(), .groups = "drop")

# Step 1: Bin playlist appearance counts
binned_data <- popularity_vs_appearances %>%
  mutate(bin = cut(
    playlist_appearances,
    breaks = c(0, 5, 10, 20, 50, 100, Inf),
    labels = c("0–5", "6–10", "11–20", "21–50", "51–100", "100+")
  ))

# Step 2: Visualize the relationship
p <- ggplot(binned_data, aes(x = bin, y = popularity)) +
  geom_boxplot(fill = "#00FF00", color = "white") +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white"),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold")
  ) +
  labs(
    title = "Track Popularity by Playlist Appearance Count",
    x = "Number of Playlist Appearances (Binned)",
    y = "Track Popularity"
  )
print(p)
```

**Analysis** - This boxplot shows that tracks appearing in more playlists generally have higher Spotify popularity scores. Median popularity rises with playlist appearances, especially beyond 20. Still, the wide range within each group suggests that **playlist exposure helps, but is not the only factor** driving popularity.

### In what year were the most popular songs released?

```{r}
#| label: prep-yearly-counts
#| message: false
#| warning: false

library (dplyr)
# Filter and count popular songs by year
popular_songs <- rectified %>%
  filter(popularity >= 75, !is.na(year))

yearly_counts <- popular_songs %>%
  count(year) %>%
  filter(year >= 1995)
```

```{r, message=FALSE, warning=FALSE}
s <- ggplot(yearly_counts, aes(x = factor(year), y = n)) +
  geom_col(fill = "#00FF00", alpha = 0.8) +
  labs(
    title = "Popular Songs by Year",
    x = "Year",
    y = "Number of Popular Songs"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white"),
    axis.text = element_text(color = "#00FF00"),
    axis.text.x = element_text(angle = 45, hjust = 1),  # 💡 Rotate x-axis labels
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold")
  )
print (s)
```

**Analysis** - Most popular songs were released after 2015, with a sharp rise in recent years. This aligns with how newer music dominates playlists due to recency bias and platform algorithms.

### In what year did danceability peak?

```{r, eval=interactive(), echo=FALSE, message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)
library(gganimate)
library(gifski)

# Step 1: Filter for popular songs
popular_dance <- rectified %>%
  filter(popularity >= 75, !is.na(danceability), !is.na(year))

# Step 2: Average danceability by year
dance_by_year <- popular_dance %>%
  group_by(year) %>%
  summarize(avg_danceability = mean(danceability)) %>%
  filter(year >= 1995)

# Step 3: Create animation plot
p <- ggplot(dance_by_year, aes(x = year, y = avg_danceability)) +
  geom_line(color = "#00FF00", size = 1.5) +
  geom_point(color = "#00FF00", size = 3) +
  labs(
    title = "Danceability Trends Over Time",
    x = "Year",
    y = "Average Danceability"
  ) +
  theme_minimal(base_size = 15) +
  theme(
    plot.background = element_rect(fill = "#121212"),
    panel.background = element_rect(fill = "#121212"),
    text = element_text(color = "#00FF00"),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(size = 18, face = "bold")
  ) +
  transition_reveal(year)

# Step 4: Save animation
a <- animate(p, width = 800, height = 500, fps = 10, duration = 8, renderer = gifski_renderer())
anim_save("danceability_trends.gif", animation = a)
```

```{r, echo=FALSE, out.width="100%"}
knitr::include_graphics("danceability_trends.gif")
```

**Analysis -** Danceability of popular songs steadily increased over time, peaking around **2019–2020**. This reflects the shift toward more rhythm-driven, upbeat music — possibly influenced by streaming-era pop, TikTok trends, and global dance tracks dominating the charts.

### Which decade is most represented on user playlists?

```{r, message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)

# Step 1: Create decade column
decade_counts <- rectified %>%
  filter(!is.na(year)) %>%
  mutate(decade = (year %/% 10) * 10) %>%
  count(decade)

# Step 2: Plot the decade frequency
d <- ggplot(decade_counts, aes(x = factor(decade), y = n)) +
  geom_col(fill = "#00FF00", alpha = 0.8) +
  labs(
    title = "Most Represented Decades on Spotify Playlists",
    x = "Decade",
    y = "Number of Tracks"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212"),
    panel.background = element_rect(fill = "#121212"),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    text = element_text(color = "#00FF00"),
    plot.title = element_text(face = "bold")
  )
print (d)
```

**Analysis** - The **2010s** dominate user playlists, followed by the 2000s. This reflects user preferences skewing toward more recent decades, likely due to recency, nostalgia, and streaming platform curation that favors modern music.

### Polar (circular) coordinates

```{r, message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)

# Updated readable labels (slash format, no flats)
key_labels <- c("C", "C#/Db", "D", "D#/Eb", "E", "F", 
                "F#/Gb", "G", "G#/Ab", "A", "A#/Bb", "B")

# Count key frequencies
key_counts <- rectified %>%
  count(key) %>%
  mutate(
    key_label = factor(key_labels[key + 1], levels = key_labels)
  )

# Polar plot
c <- ggplot(key_counts, aes(x = key_label, y = n, fill = key_label)) +
  geom_bar(stat = "identity", color = "white", width = 1) +
  coord_polar(start = 0) +
  scale_fill_manual(values = rep("#00FF00", 12)) +
  labs(
    title = "Distribution of Musical Keys",
    x = NULL,
    y = "Number of Songs"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white", linewidth = 0.3),
    panel.grid.minor = element_blank(),
    axis.text.y = element_text(color = "#00FF00"),
    axis.text.x = element_text(color = "#00FF00", size = 12, vjust = -0.8),
    axis.title.y = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold"),
    legend.position = "none"
  )
print (c)
```

**Analysis** - The distribution of track lengths shows a clear peak between **3 to 4 minutes** (around **180–240 seconds**), with the most popular duration near **210 seconds**. This suggests that mid-length songs are the most playlist-friendly—long enough to feel complete but short enough to hold attention. Tracks that are very short or very long appear far less frequently, likely because they’re either intros/skits or extended versions not suited for general playlists.

### What are the most popular track lengths? (Are short tracks, long tracks, or something in between most commonly included in user playlists

```{r, message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)

# Convert milliseconds to seconds 
lengths_data <- rectified %>%
  mutate(duration_sec = duration / 1000) %>%
  filter(duration_sec >= 60, duration_sec <= 600)  # Keep songs between 1–10 min

# Histogram of track lengths
t <- ggplot(lengths_data, aes(x = duration_sec)) +
  geom_histogram(fill = "#00FF00", color = "white", binwidth = 10) +
  labs(
    title = "Distribution of Track Lengths in Playlists",
    x = "Track Length (seconds)",
    y = "Number of Tracks"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white", linewidth = 0.3),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold")
  )
print(t)
```

**Analysis** - Most tracks in user playlists fall between **3 to 4 minutes**, with a noticeable peak around **210 seconds**. This suggests that songs of moderate length are the most commonly included—probably because they strike the right balance between listener attention and playlist flow. Very short or long tracks are much less frequent, indicating that mid-length songs tend to be the sweet spot for popularity.

## Two more visualization

### Additional Exploratory questions

#### 1️⃣ Are explicit songs more or less popular than non-explicit songs?

```{r}
library(ggplot2)
library(dplyr)

# Convert 'explicit' to label
combined_data <- combined_data %>%
  mutate(explicit_label = ifelse(explicit.x == 1, "Explicit", "Non-Explicit"))

# Boxplot comparison
e <- ggplot(combined_data, aes(x = explicit_label, y = popularity.x, fill = explicit_label)) +
  geom_boxplot(color = "white", width = 0.5) +
  scale_fill_manual(values = c("Explicit" = "#FF4500", "Non-Explicit" = "#00FF00")) +
  labs(
    title = "Popularity of Explicit vs Non-Explicit Songs",
    x = "Song Type",
    y = "Popularity"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white", linewidth = 0.3),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold"),
    legend.position = "none"
  )
print (e)
```

**Analysis** - Looks like keeping it clean might actually pay off — non-explicit songs seem to have a slight edge in popularity. While both types are doing decently well, the clean tracks have a higher median and a chunkier upper range. So yeah, maybe being radio-friendly isn’t such a bad thing after all.

#### 2️⃣ Do popular songs tend to be more “positive” in valence?

```{r}
library(ggplot2)
library(dplyr)

# Create popularity group
combined_data <- combined_data %>%
  mutate(popularity_group = ifelse(popularity.x >= 60, "Popular", "Less Popular"))

# Boxplot comparing valence (positivity)
v <- ggplot(combined_data, aes(x = popularity_group, y = valence.x, fill = popularity_group)) +
  geom_boxplot(color = "white") +
  scale_fill_manual(values = c("Popular" = "#00FF00", "Less Popular" = "#FF69B4")) +
  labs(
    title = "Valence Scores by Popularity Group",
    x = "Popularity Group",
    y = "Valence (Positivity Score)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white", linewidth = 0.3),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold")
  )
print (v)
```

**Analysis** - Turns out, popular songs do lean a *little* more positive, but it’s not a huge mood swing. The median valence score is just a bit higher for popular tracks, so while they’re vibing higher, it’s not all sunshine and rainbows. Basically, being a bop doesn't always mean being bright and bubbly — but it sure doesn't hurt.

## From Anchor to Anthem: Crafting the Playlist 💿 ➡️ 🎧

```{r}
# Set anchor songs
anchor_songs <- combined_data %>%
  filter(track_name %in% c("HUMBLE.", "White Iverson"))

# Get their track IDs for matching
anchor_ids <- anchor_songs$track_id
```

```{r}
# Find songs that appear on the same playlists
playlist_overlap_songs <- combined_data %>%
  filter(track_id %in% anchor_ids) %>%
  distinct(playlist_id) %>%
  inner_join(combined_data, by = "playlist_id") %>%
  filter(!track_id %in% anchor_ids) %>%
  distinct(track_id, track_name, artist_name)

```

```{r}
library(dplyr)

# Step 1: Extract key and tempo of anchor songs and rename for simplicity
anchor_keys_tempos <- anchor_songs %>%
  distinct(key.x, tempo.x) %>%
  rename(key = key.x, tempo = tempo.x)

# Step 2: Filter songs in combined_data with similar key and tempo ± 5
harmonic_matches <- combined_data %>%
  filter(
    key.x %in% anchor_keys_tempos$key,
    tempo.x >= min(anchor_keys_tempos$tempo) - 5,
    tempo.x <= max(anchor_keys_tempos$tempo) + 5,
    !track_id %in% anchor_ids
  ) %>%
  distinct(track_id, track_name, artist_name)
```

Step4

```{r}
# Filter songs by same artist
same_artist_songs <- combined_data %>%
  filter(artist_name %in% anchor_songs$artist_name) %>%
  filter(!track_id %in% anchor_ids) %>%
  distinct(track_id, track_name, artist_name)
```

Step5

```{r}
library(dplyr)
library(lubridate)

# Anchor song traits
anchor_traits <- anchor_songs %>%
  mutate(year = suppressWarnings(year(mdy(release_date.x)))) %>%
  filter(!is.na(year)) %>%
  summarise(
    anchor_year = first(year),
    acoustic_min = min(acousticness.x, na.rm = TRUE),
    acoustic_max = max(acousticness.x, na.rm = TRUE),
    dance_min = min(danceability.x, na.rm = TRUE),
    dance_max = max(danceability.x, na.rm = TRUE)
  )

# Filter based on year, acousticness, and danceability
similar_trait_songs <- combined_data %>%
  mutate(year = suppressWarnings(year(mdy(release_date.x)))) %>%
  filter(
    !is.na(year),
    year == anchor_traits$anchor_year,
    acousticness.x >= anchor_traits$acoustic_min - 0.05,
    acousticness.x <= anchor_traits$acoustic_max + 0.05,
    danceability.x >= anchor_traits$dance_min - 0.05,
    danceability.x <= anchor_traits$dance_max + 0.05
  ) %>%
  distinct(track_id, track_name, artist_name)
```

Step 6

```{r}
# Songs with similar valence (positivity)
valence_range <- range(anchor_songs$valence.x, na.rm = TRUE)

vibe_matches <- combined_data %>%
  filter(
    valence.x >= valence_range[1] - 0.1,
    valence.x <= valence_range[2] + 0.1,
    !track_id %in% anchor_ids
  ) %>%
  distinct(track_id, track_name, artist_name)
```

Step 7

```{r, include=FALSE}
# Combine all sets
final_candidates <- bind_rows(
  playlist_overlap_songs,
  harmonic_matches,
  same_artist_songs,
  similar_trait_songs,
  vibe_matches
) %>%
  distinct(track_id, track_name, artist_name) %>%
  slice_head(n = 20)

final_candidates
```

Step - Combine and select top 20 songs

```{r}
# Match songs by same artist
artist_matches <- combined_data %>%
  filter(
    artist_name %in% anchor_songs$artist_name,
    !track_id %in% anchor_ids
  ) %>%
  distinct(track_id, track_name, artist_name)

# Match songs by same release year
yearstyle_matches <- combined_data %>%
  filter(
    year.x %in% anchor_songs$year.x,
    !track_id %in% anchor_ids
  ) %>%
  distinct(track_id, track_name, artist_name)

# Match songs that appear on same playlists as anchor songs
cooccurrence_matches <- combined_data %>%
  filter(
    playlist_id %in% (
      combined_data %>%
        filter(track_id %in% anchor_ids) %>%
        pull(playlist_id)
    ),
    !track_id %in% anchor_ids
  ) %>%
  distinct(track_id, track_name, artist_name)

# Combine all matches
all_matches <- bind_rows(
  harmonic_matches,
  artist_matches,
  yearstyle_matches,
  cooccurrence_matches
) %>%
  distinct(track_id, .keep_all = TRUE) %>%
  filter(!track_id %in% anchor_ids)
```

Step - Slice top 20

```{r}
final_candidates <- all_matches %>%
  left_join(
    combined_data %>%
      select(
        track_id,
        popularity = popularity.x,
        danceability = danceability.x,
        valence = valence.x   
      ),
    by = "track_id"
  ) %>%
  distinct(track_id, track_name, artist_name, .keep_all = TRUE) %>%
  arrange(desc(popularity)) %>%
  slice_head(n = 20)
```

Step - Preview the playlist

```{r}
library(DT)

datatable(
  final_candidates %>%
    select(track_name, artist_name, popularity),
  options = list(
    pageLength = 20,
    autoWidth = TRUE,
    dom = 't'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = c("track_name", "artist_name", "popularity"),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

# The Ultimate Playlist 🎧 ▶️

Step 1

```{r}
ultimate_playlist <- final_candidates %>%
  arrange(danceability, desc(popularity)) %>%
  slice(1:12)
```

Step 2

```{r}
playlist_title <- "Neon Nights: A Vibe-Driven Ride"
```

Step 3

```{r}
# Add track order again just in case
ultimate_playlist <- final_candidates %>%
  mutate(track_order = row_number())

# Now plot valence (emotional arc)
arc <- ggplot(ultimate_playlist, aes(x = factor(track_order), y = valence, group = 1)) +
  geom_line(color = "#00FF00", size = 1.2) +
  geom_point(color = "white", size = 3) +
  labs(
    title = "Emotional Arc: Valence Across Playlist",
    x = "Track Order",
    y = "Valence (Positivity)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white", linewidth = 0.3),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold")
  )
print (arc)
```

**Title**: *Echoes of Euphoria*\
**Description**: "Echoes of Euphoria" is a carefully curated playlist designed to elevate your mood with a mix of upbeat and dreamy tracks. Perfect for moments when you want to feel energized and immersed in an uplifting musical journey.\
**Design Principles**:

-   Balanced valence for emotional shifts

-   Harmonic flow using similar keys

-   Features 3 underrated tracks & 2 songs I had never heard before

-   Anchored on *HUMBLE.* and *White Iverson*

# Bonus Track 🎞️

For this project, HUMBLE. by Kendrick Lamar serves as my anchor song, capturing the core themes I’m exploring. I also selected Take On Me by a-ha and The Scientist by Coldplay from my ultimate playlist to complement and expand on the project’s mood and message.

```{=html}
<iframe width="640" height="360" src="https://www.youtube.com/embed/tvTRZJ-4EyI?si=CGLD4MiXzQcOTFKN" frameborder="0" allowfullscreen></iframe>
```

```{=html}
<iframe width="640" height="360" src="https://www.youtube.com/embed/djV11Xbc914?si=hhAZg3h6VsGUeR8" frameborder="0" allowfullscreen></iframe>
```

```{=html}
<iframe width="640" height="360" src="https://www.youtube.com/embed/RB-RcX5DS5A?si=aBaezMFfSrmcYzGs" frameborder="0" allowfullscreen></iframe>
```

# Outro 🎶

This project, "Tracks and Stats," has been an exciting journey where music meets analytics. From ingesting and cleaning Spotify datasets to uncovering trends in popularity, danceability, and playlist composition, we've explored the factors that make a song resonate with millions. Through descriptive analysis, visualizations, and inferential modeling, we’ve decoded the rhythm behind the stats.

The result? A curated playlist, **”Echoes of Euphoria,”** that harmonizes data-driven insights with personal creativity. This playlist exemplifies how analytics can transform raw data into a cohesive musical narrative, blending tempo, energy, and valence for an unforgettable listening experience.

As we close the loop, "Tracks and Stats" serves not only as a reflection of our love for music but also as a testament to the power of data in shaping experiences that resonate, inspire, and connect.

Keep vibing, keep analyzing, and let the music play!

## Echoes of Euphoria

Spotify does not house clean versions for a lot of these songs.

<iframe style="border-radius:12px" src="https://open.spotify.com/embed/playlist/7zUi7tsyA3eF1YNaNyIMn4?utm_source=generator" width="100%" height="380" frameborder="0" allowtransparency="true" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy">

</iframe>
