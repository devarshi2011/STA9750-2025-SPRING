---
title: |
  <span style="display: inline-flex; align-items: center;">
    <img src="images/spotify.png" style="height: 40px; margin-right: 10px;">
    Tracks and Stats 🎵
  </span>
subtitle: "Where Music Meets Analytics"
author: "Dev Lala"
format:
  html:
    code-fold: true
    code-summary: "Show the code"
    theme:
      light: minty
      dark: darkly
    css: spotifystyle.css
    toc: false
    toc-location: left
    number-sections: false
    smooth-scroll: true
    title-block-banner: true
    page-layout: full
editor: visual
---

## Popular Artists 🎤

::: {style="display: flex; align-items: center; justify-content: flex-start; gap: 30px; margin-bottom: 40px;"}
<img src="images/kendrick.jpg" width="200px" style="border-radius: 50%;"/> <img src="images/eminem.jpg" width="200px" style="border-radius: 50%;"/> <img src="images/coldplay.jpg" width="200px" style="border-radius: 50%;"/> <img src="images/gorillaz.jpg" width="200px" style="border-radius: 50%;"/> <img src="images/empire.jpg" width="200px" style="border-radius: 50%;"/>
:::

While these are some of my personal favorite artists—the ones that define my everyday playlists and late-night loops—this project takes a broader lens. I’ll be exploring Spotify data to analyze trends across various artists, genres, and tracks to uncover the characteristics that make a song stand out and rise to popularity. It’s less about personal taste, and more about what the data reveals about music that resonates with millions

# Intro Track 🎙️

Welcome to Tracks and Stats — where the world of music meets the power of data!

In this project, we dive into Spotify’s data exports to uncover the trends and characteristics behind today’s most popular songs. Using real-world analytics, we work toward building The Ultimate Playlist — a collection inspired by the legendary spirit of Mr. Barney Stinson’s “All Rise” playlist, but customized to reflect our own vision of what ultimate music sounds like.

Through the lens of Tracks and Stats, we explore top artists, trending songs, and musical patterns that define what makes a track truly unforgettable.

# Main Chorus 🎶

-   Ingest and clean Spotify datasets to prepare for analysis.

-   Combine multiple data sources to create a richer dataset.

-   Perform descriptive analysis and visualize key trends.

-   Apply inferential modeling to build **The Ultimate Playlist**.

# **Data Soundcheck** 📀

In this section, I’ve loaded and cleaned two datasets: one with song characteristics like acousticness and tempo, and another with playlist details such as track order and metadata. These datasets are now ready for analysis.

### [Track Traits 🎸]{style="color:#1DB954;"}

This section displays a dataset of songs with key traits like acousticness, danceability, tempo, loudness, popularity, and more. Each row represents a song along with its ID, release date & year, artist and various other characteristics

```{r, include=FALSE}
library(dplyr)
library(tidyr)
library(stringr)
library(readr)
library(tidyverse)
library(DT)
```

```{r, message=FALSE, warning=FALSE}

# Function to load and clean songs data
load_songs <- function() {
  dir_name <- file.path("data", "mp03")
  dir.create(dir_name, showWarnings = FALSE, recursive = TRUE)
  
  file_path <- file.path(dir_name, "spotify_songs.csv")
  
  if (!file.exists(file_path)) {
    download.file(
      url = "https://raw.githubusercontent.com/gabminamedez/spotify-data/refs/heads/master/data.csv",
      destfile = file_path,
      extra = "-L -A 'Mozilla/5.0'", # Trick GitHub download
      method = "libcurl"
    )
  }
  
  songs_data <- read.csv(file_path)
  
  clean_artist_string <- function(x) {
    str_replace_all(x, "\\['", "") |> 
      str_replace_all("'\\]", "") |> 
      str_replace_all(" '", "") 
  }
  
  songs_clean <- songs_data |> 
    separate_longer_delim(artists, ",") |> 
    mutate(artist = clean_artist_string(artists)) |> 
    select(-artists)
  
  return(songs_clean)
}

# Load and clean the data
songs <- load_songs()

```

```{r}
library(DT)

datatable(
  head(songs, 100),
  options = list(
    pageLength = 10,
    autoWidth = TRUE,
    dom = 'lfrtip' # keep 'Show entries' (l), 'Search' (f), table (t), pagination (p)
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(songs),
    backgroundColor = '#121212',  # Black background
    color = '#00FF00'  # Bright green text
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      // Change text color of 'Show entries' label
      $(el).parent().find('label').css('color', '#00FF00');
      // Change text color inside 'Search' input
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      // Also adjust the dropdown box
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

### [Playlist Breakdown 🎧]{style="color:#1DB954;"}

This section showcases a dataset of playlists, detailing the songs included, their order, and additional metadata like artist names and track attributes. It offers a comprehensive view of how different songs are grouped in playlists, a.k.a **‘Rectangle’ the Playlist Data.**

```{r, message=FALSE, warning=FALSE, include=FALSE}
library(jsonlite)
library(purrr)
library(dplyr)
library(tidyr)
library(stringr)

load_playlists <- function(n_files = 5) {
  # 1. Create directory
  dir_name <- file.path("data", "mp03_playlists")
  dir.create(dir_name, showWarnings = FALSE, recursive = TRUE)

  # 2. Base URL
  base_url <- "https://raw.githubusercontent.com/DevinOgrady/spotify_million_playlist_dataset/refs/heads/main/data1/mpd.slice.0-999.json"
  slice_starts <- seq(0, 999000, by = 1000)  # all files
  filenames <- paste0("mpd.slice.", slice_starts, "-", slice_starts + 999, ".json")

  # 3. Download all files (responsibly)
  for (filename in filenames) {
    local_file <- file.path(dir_name, filename)
    if (!file.exists(local_file)) {
      tryCatch({
        download.file(
          url = paste0(base_url, filename),
          destfile = local_file,
          method = "libcurl",
          quiet = TRUE
        )
        message(paste("Downloaded:", filename))
      }, error = function(e) {
        message(paste("Failed to download:", filename))
      })
    }
  }

  # 4. Read only the first n_files into R
  safe_read_json <- purrr::possibly(fromJSON, otherwise = NULL)
  selected_files <- filenames[1:n_files]
  playlists_list <- list()

  for (filename in selected_files) {
    local_file <- file.path(dir_name, filename)
    if (file.exists(local_file)) {
      playlists_list[[filename]] <- safe_read_json(local_file, flatten = TRUE)
    }
  }

  return(playlists_list)
}

# Load only the first 5 files (you can change to 10 if you want)
playlists_raw <- load_playlists(n_files = 5)
```

```{r}
# Save the raw playlists
saveRDS(playlists_raw, "data/playlists_raw.rds")
```

```{r, message=FALSE, warning=FALSE}
# Load necessary libraries
library(purrr)
library(dplyr)
library(tidyr)
library(stringr)

# Load your raw playlist data
playlists_raw <- readRDS("data/playlists_raw.rds")  # 🔁 Update path if needed

# Function to strip Spotify URI prefixes
strip_spotify_prefix <- function(x) {
  str_extract(x, ".*:.*:(.*)")
}

# Combine all playlist data from loaded list
all_playlists <- map_dfr(playlists_raw, ~ .x$playlists, .id = "source_file")

# Create rectified_data from nested structure
rectified_data <- all_playlists %>%
  select(
    playlist_name = name,
    playlist_id = pid,
    playlist_followers = num_followers,
    tracks
  ) %>%
  unnest(tracks) %>%
  mutate(
    playlist_position = row_number(),
    artist_name = map_chr(artist_name, 1, .default = NA_character_),
    artist_id = strip_spotify_prefix(artist_uri),
    track_name = track_name,
    track_id = str_extract(strip_spotify_prefix(track_uri), "[^:]+$"),
    album_name = album_name,
    album_id = strip_spotify_prefix(album_uri),
    duration = duration_ms
  ) %>%
  select(
    playlist_name, playlist_id, playlist_position, playlist_followers,
    artist_name, artist_id, track_name, track_id,
    album_name, album_id, duration
  )

# Clean song metadata
songs_clean <- songs %>%
  distinct(id, .keep_all = TRUE)

# Join playlist and song metadata
rectified <- rectified_data %>%
  inner_join(songs_clean, by = c("track_id" = "id"))

# Preview final joined dataset
head(rectified, 10)
```

```{r}
library(DT)

# Show the first 100 rows of rectified_data in a styled table
datatable(
  head(rectified, 100),
  options = list(
    pageLength = 10,
    autoWidth = TRUE,
    dom = 'lfrtip' # show search, pagination, etc
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(rectified),
    backgroundColor = '#121212',  # black background
    color = '#00FF00'             # bright green text
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

# Exploring the Tracks 🔍 🎵

1.  How many distinct tracks and artists are represented in the playlist data?

```{r}
library(dplyr)
library(DT)

# 1A: How many distinct tracks?
distinct_tracks <- n_distinct(rectified$track_id)

# 1B: How many distinct artists?
distinct_artists <- n_distinct(rectified$artist_id)

# Create a small tibble to display both answers
q1_table <- tibble::tibble(
  Metric = c("Distinct Tracks", "Distinct Artists"),
  Count = c(distinct_tracks, distinct_artists)
)

# Now display the table nicely with your theme
datatable(
  q1_table,
  options = list(
    pageLength = 10,
    autoWidth = TRUE,
    dom = 'lfrtip'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(q1_table),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

2.  What are the 5 most popular tracks in the playlist data?

```{r}
library(dplyr)
library(DT)

# Q2: Get top 5 most popular tracks
top5_tracks <- rectified %>%
  count(track_name, sort = TRUE) %>%
  slice_head(n = 5)

# Display the result nicely with your dark theme
datatable(
  top5_tracks,
  options = list(
    pageLength = 5,
    autoWidth = TRUE,
    dom = 'lfrtip'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(top5_tracks),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

3.  What is the most popular track in the playlist data that *does not have a corresponding entry in the song characteristics* data?

```{r}
library(dplyr)
library(DT)

# Find the most popular tracks from rectified data
popular_tracks <- rectified %>%
  count(track_name, sort = TRUE)

# Find tracks in playlists but missing from songs dataset
tracks_not_in_songs <- anti_join(
  popular_tracks,
  songs,
  by = c("track_name" = "name")
)

# Get the most popular missing track
most_popular_missing_track <- tracks_not_in_songs %>%
  slice_head(n = 1)

# Display it nicely
datatable(
  most_popular_missing_track,
  options = list(
    pageLength = 1,
    autoWidth = TRUE,
    dom = 'lfrtip'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(most_popular_missing_track),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

4.  According to the song characteristics data, what is the most “danceable” track? How often does it appear in a playlist?

```{r}
library(dplyr)
library(DT)

# Find the most danceable track
most_danceable_track <- songs %>%
  arrange(desc(danceability)) %>%
  slice_head(n = 1)

# Display it nicely
datatable(
  most_danceable_track,
  options = list(
    pageLength = 1,
    autoWidth = TRUE,
    dom = 'lfrtip'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(most_danceable_track),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

```{r}
library(dplyr)
library(DT)

# Get the most danceable track name from songs
most_danceable_track_name <- songs %>%
  arrange(desc(danceability)) %>%
  slice_head(n = 1) %>%
  pull(name)

# Count how many times it appears in playlists (rectified data)
most_danceable_appearance_count <- rectified %>%
  filter(track_name == most_danceable_track_name) %>%
  nrow()

# Create a tibble to display the result
q4_appearance_table <- tibble::tibble(
  Most_Danceable_Track = most_danceable_track_name,
  Number_of_Appearances = most_danceable_appearance_count
)

# Display it with your neon black styling
datatable(
  q4_appearance_table,
  options = list(
    pageLength = 1,
    autoWidth = TRUE,
    dom = 'lfrtip'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(q4_appearance_table),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

According to the song characteristics data, the most danceable track is "Funky Cold Medina". However, it has only one appearance in the playlists from the playlist dataset.

5.  Which playlist has the longest average track length?

```{r}
library(dplyr)
library(DT)

# Find the playlist with the longest average track duration
longest_playlist <- rectified %>%
  group_by(playlist_id, playlist_name) %>%
  summarize(avg_duration = mean(duration, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(avg_duration)) %>%
  slice_head(n = 1)

# Display the result
datatable(
  longest_playlist,
  options = list(
    pageLength = 1,
    autoWidth = TRUE,
    dom = 'lfrtip'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(longest_playlist),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

6.  What is the most popular playlist on Spotify?

```{r}
library(dplyr)
library(DT)

# Join rectified_data with songs to get popularity info
most_popular_playlist <- rectified %>%
  select(playlist_name, playlist_followers) %>%
  distinct() %>%
  arrange(desc(playlist_followers)) %>%
  slice_head(n = 1)

# Displaying it in my dark green neon setup
datatable(
  most_popular_playlist,
  options = list(
    pageLength = 1,
    autoWidth = TRUE,
    dom = 't'
  ),
  rownames = FALSE,
  class = 'cell-border stripe hover'
) %>%
  formatStyle(
    columns = names(most_popular_playlist),
    backgroundColor = '#121212',
    color = '#00FF00'
  ) %>%
  htmlwidgets::onRender("
    function(el, x) {
      $(el).parent().find('label').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('color', '#00FF00');
      $(el).parent().find('input[type=search]').css('background-color', '#121212');
      $(el).parent().find('select').css('color', '#00FF00');
      $(el).parent().find('select').css('background-color', '#121212');
    }
  ")
```

Task 5

```{r, message=FALSE, warning=FALSE}
#| label: load-playlists
#| message: false
#| warning: false
library(dplyr)

# Joining playlist and song characteristics data on track ID
songs_clean <- songs %>%
  distinct(id, .keep_all = TRUE)

combined_data <- rectified %>%
  inner_join(songs_clean, by = c("track_id" = "id"))

# Force visible output for rendering
head(combined_data)
```

Q1 Is the popularity column correlated with the number of playlist appearances? If so, to what degree?

```{r, message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)

# Create data frame with track popularity and playlist appearance counts
popularity_vs_appearances <- rectified %>%
  group_by(track_id, popularity) %>%
  summarise(playlist_appearances = n(), .groups = "drop")

# Step 1: Bin playlist appearance counts
binned_data <- popularity_vs_appearances %>%
  mutate(bin = cut(
    playlist_appearances,
    breaks = c(0, 5, 10, 20, 50, 100, Inf),
    labels = c("0–5", "6–10", "11–20", "21–50", "51–100", "100+")
  ))

# Step 2: Visualize the relationship
ggplot(binned_data, aes(x = bin, y = popularity)) +
  geom_boxplot(fill = "#00FF00", color = "white") +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white"),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold")
  ) +
  labs(
    title = "Track Popularity by Playlist Appearance Count",
    x = "Number of Playlist Appearances (Binned)",
    y = "Track Popularity"
  )
```

**Analysis** - This boxplot shows that tracks appearing in more playlists generally have higher Spotify popularity scores. Median popularity rises with playlist appearances, especially beyond 20. Still, the wide range within each group suggests that **playlist exposure helps, but is not the only factor** driving popularity.

### In what year were the most popular songs released?

```{r, message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)

# Filter popular songs (popularity >= 75)
popular_songs <- rectified %>%
  filter(popularity >= 75, !is.na(year))

# Count how many were released per year
yearly_counts <- popular_songs %>%
  count(year) %>%
  filter(year >= 1995)  # optional: filter to keep it clean

# Plot - clean, rotated, and readable
ggplot(yearly_counts, aes(x = factor(year), y = n)) +
  geom_col(fill = "#00FF00", alpha = 0.8) +
  labs(
    title = "Popular Songs by Year",
    x = "Year",
    y = "Number of Popular Songs"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white"),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold")
  )
```

**Analysis** - Most popular songs were released after 2015, with a sharp rise in recent years. This aligns with how newer music dominates playlists due to recency bias and platform algorithms.

### In what year did danceability peak?

```{r, eval=interactive(), echo=FALSE, message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)
library(gganimate)
library(gifski)

# Step 1: Filter for popular songs
popular_dance <- rectified %>%
  filter(popularity >= 75, !is.na(danceability), !is.na(year))

# Step 2: Average danceability by year
dance_by_year <- popular_dance %>%
  group_by(year) %>%
  summarize(avg_danceability = mean(danceability)) %>%
  filter(year >= 1995)

# Step 3: Create animation plot
p <- ggplot(dance_by_year, aes(x = year, y = avg_danceability)) +
  geom_line(color = "#00FF00", size = 1.5) +
  geom_point(color = "#00FF00", size = 3) +
  labs(
    title = "Danceability Trends Over Time",
    x = "Year",
    y = "Average Danceability"
  ) +
  theme_minimal(base_size = 15) +
  theme(
    plot.background = element_rect(fill = "#121212"),
    panel.background = element_rect(fill = "#121212"),
    text = element_text(color = "#00FF00"),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(size = 18, face = "bold")
  ) +
  transition_reveal(year)

# Step 4: Save animation
a <- animate(p, width = 800, height = 500, fps = 10, duration = 8, renderer = gifski_renderer())
anim_save("danceability_trends.gif", animation = a)
```

```{r, echo=FALSE, out.width="100%"}
knitr::include_graphics("danceability_trends.gif")
```

**Analysis -** Danceability of popular songs steadily increased over time, peaking around **2019–2020**. This reflects the shift toward more rhythm-driven, upbeat music — possibly influenced by streaming-era pop, TikTok trends, and global dance tracks dominating the charts.

### Which decade is most represented on user playlists?

```{r, message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)

# Step 1: Create decade column
decade_counts <- rectified %>%
  filter(!is.na(year)) %>%
  mutate(decade = (year %/% 10) * 10) %>%
  count(decade)

# Step 2: Plot the decade frequency
ggplot(decade_counts, aes(x = factor(decade), y = n)) +
  geom_col(fill = "#00FF00", alpha = 0.8) +
  labs(
    title = "Most Represented Decades on Spotify Playlists",
    x = "Decade",
    y = "Number of Tracks"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212"),
    panel.background = element_rect(fill = "#121212"),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    text = element_text(color = "#00FF00"),
    plot.title = element_text(face = "bold")
  )

```

**Analysis** - The **2010s** dominate user playlists, followed by the 2000s. This reflects user preferences skewing toward more recent decades, likely due to recency, nostalgia, and streaming platform curation that favors modern music.

### Polar (circular) coordinates

```{r, message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)

# Updated readable labels (slash format, no flats)
key_labels <- c("C", "C#/Db", "D", "D#/Eb", "E", "F", 
                "F#/Gb", "G", "G#/Ab", "A", "A#/Bb", "B")

# Count key frequencies
key_counts <- rectified %>%
  count(key) %>%
  mutate(
    key_label = factor(key_labels[key + 1], levels = key_labels)
  )

# Polar plot
ggplot(key_counts, aes(x = key_label, y = n, fill = key_label)) +
  geom_bar(stat = "identity", color = "white", width = 1) +
  coord_polar(start = 0) +
  scale_fill_manual(values = rep("#00FF00", 12)) +
  labs(
    title = "Distribution of Musical Keys",
    x = NULL,
    y = "Number of Songs"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white", linewidth = 0.3),
    panel.grid.minor = element_blank(),
    axis.text.y = element_text(color = "#00FF00"),
    axis.text.x = element_text(color = "#00FF00", size = 12, vjust = -0.8),
    axis.title.y = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold"),
    legend.position = "none"
  )
```

**Analysis** - The distribution of track lengths shows a clear peak between **3 to 4 minutes** (around **180–240 seconds**), with the most popular duration near **210 seconds**. This suggests that mid-length songs are the most playlist-friendly—long enough to feel complete but short enough to hold attention. Tracks that are very short or very long appear far less frequently, likely because they’re either intros/skits or extended versions not suited for general playlists.

### What are the most popular track lengths? (Are short tracks, long tracks, or something in between most commonly included in user playlists

```{r, message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)

# Convert milliseconds to seconds (if needed)
lengths_data <- rectified %>%
  mutate(duration_sec = duration / 1000) %>%
  filter(duration_sec >= 60, duration_sec <= 600)  # Keep songs between 1–10 min

# Histogram of track lengths
ggplot(lengths_data, aes(x = duration_sec)) +
  geom_histogram(fill = "#00FF00", color = "white", binwidth = 10) +
  labs(
    title = "Distribution of Track Lengths in Playlists",
    x = "Track Length (seconds)",
    y = "Number of Tracks"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.background = element_rect(fill = "#121212", color = NA),
    panel.background = element_rect(fill = "#121212", color = NA),
    panel.grid.major = element_line(color = "white", linewidth = 0.3),
    axis.text = element_text(color = "#00FF00"),
    axis.title = element_text(color = "#00FF00"),
    plot.title = element_text(color = "#00FF00", size = 16, face = "bold")
  )
```

**Analysis** - Most tracks in user playlists fall between **3 to 4 minutes**, with a noticeable peak around **210 seconds**. This suggests that songs of moderate length are the most commonly included—probably because they strike the right balance between listener attention and playlist flow. Very short or long tracks are much less frequent, indicating that mid-length songs tend to be the sweet spot for popularity.

## Two more visualization

### Additional Exploratory questions

#### 1️⃣ Are explicit songs more or less popular than non-explicit songs?

```{r}
library(dplyr)
library(ggplot2)


```

**Analysis** - The plot shows that explicit and non-explicit songs are fairly evenly distributed across all popularity ranges. Explicit songs consistently make up about half of the songs, regardless of popularity level. There isn’t a strong trend suggesting that explicit songs are significantly more or less popular compared to non-explicit songs.

#### 2️⃣ How does valence differ between popular and less popular songs?

```{r}
library(ggplot2)

```

**Analysis** - The box plot shows that popular and less popular songs have a very similar distribution of valence scores. Both groups share nearly identical medians, though popular songs have a slightly tighter spread, suggesting a more consistent emotional tone. Overall, positivity does not strongly differ between the two groups.

## From Anchor to Anthem: Crafting the Playlist 💿 ➡️ 🎧

```{r}

```

```{r}

```

Analysis - I used two anchor songs and applied a few heuristics to identify related songs for playlist building. Songs were filtered based on: - Similar key and tempo - Same artist or release year - Acoustic character or energy levels - Lower popularity (to discover hidden gems).

Out of the 20 songs shown below, at least 8 are not considered popular.

# From Vinyl to Viral 📼

# Bonus Track 🎞️

Catch a glimpse of the tracks in motion with these featured song videos.
